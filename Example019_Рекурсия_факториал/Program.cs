// Определим функцию или метод, который будет принимать число, факториал которого нужно
// вычислить. Как вы понимаете, это снова метод, который принимает какой-то аргумент (в частности,
// число) и возвращает факториал этого числа.
// Определим метод как возвращающий int, и в качестве аргумента принимающий другое целое число.
// Далее по определению факториала мы явно укажем: «если мы дошли до единицы (n = 1), мы должны
// вернуть 1». Почему? Это определение факториала: 1! = 1. Кстати, отметим, что 0! — это тоже 1.
// Итак, если n = 1, возвращаем 1. В противном случае берём текущее значение и умножаем на факториал
// предыдущего числа (n - 1). Не забываем, что мы должны явно возвращать значение. То есть, если 1,
// возвращаем 1. Если не 1, то n * Factorial(n-1) (факториал предыдущего числа). 

// int Factorial(int n)
// {
//     if (n == 1) return 1; // 1! == 1
//     else return n * Factorial(n -1);
// }

// Console.WriteLine(Factorial(5)); // 1*2*3 = 6

//Комментируем предыд. пример.

//Есть ли ещё какие-то знакомые вам рекурсивные математические функции? Да, например,
// числа Фибоначчи, где каждое следующее число задаётся предыдущим. Давайте попробуем написать
// кодом вывод этих чисел.
// Для начала укажем определение. Первое число можно указать как f(1)=1, дальше — f(2)=1. Для всех
// следующих — то есть, f(n) — мы определяем числа Фибоначчи как f(n-1) + f(n-2).
//Давайте напишем этот код.

double Fibonacci(int n)
{
    if (n == 1 || n == 2) return 1;
    else return Fibonacci(n - 1) + Fibonacci(n - 2);

}

for (int i = 1; i < 50; i++)
    {
        Console.WriteLine($"f({i}) = {Fibonacci(i)}");
    }